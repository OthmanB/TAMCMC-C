@outputs_txt_lib
; function that reads outputs files with the parameters and generated by 
; the TAMCMC-C++ written in ASCII.
function read_params, file_params, maxentries=maxentries

file_session=3

if n_elements(maxentries) eq 0 then maxentries=3d6 ; 3 millions of inputs maximum by defaut

openr, file_session, file_params

	a='#'
	b=byte(a)
	i=0d
	while EOF(file_session) ne 1 do begin
		while b[0] eq 35 do begin
			readf, file_session, a; // skip comment lines by looking for the # symbol
			b=byte(a);
		endwhile
		while b[0] eq 33 do begin
			pos_eq=where(b eq 61) ; Identify the = symbol... the value should follow the sign
			name_in=strtrim(b[1:pos_eq-1],2); get the variable name
			if name_in eq 'Nchains' then Nchains=long(string(b[pos_eq+1:*]))
			if name_in eq 'Nvars' then Nvars=long(string(b[pos_eq+1:*]))
			if name_in eq 'Ncons' then Ncons=long(string(b[pos_eq+1:*]))
			if name_in eq 'chain' then chain=long(string(b[pos_eq+1:*]))
			if name_in eq 'plength' then plength=long(str_to_arrdbl(string(b[pos_eq+1:*])))
			if name_in eq 'constant_names' then cons_names=str_to_arrstr(string(b[pos_eq+1:*]))
			if name_in eq 'constant_values' then cons=str_to_arrdbl(string(b[pos_eq+1:*]));
			if name_in eq 'variable_names' then vars_names=str_to_arrstr(string(b[pos_eq+1:*]))
			
			readf, file_session, a
			b=byte(a);
		endwhile
		vars=get_Ncolumns(file_session, Nvars, maxentries)
	endwhile
close, file_session	

Ndata=n_elements(vars[*,0])

if Ncons eq 0 then Ncons=1

struc={Nchains:0l, Nvars:0l, Ncons:0l, chain:0l, Ndata:0l, plength:lonarr(n_elements(plength)), $
	   cons_names:strarr(Ncons), vars_names:strarr(Nvars), $
	   vars:dblarr(Nvars, Ndata)}

struc.Ndata=Ndata
struc.Nchains=Nchains
struc.Nvars=Nvars
struc.Ncons=Ncons
struc.chain=chain
struc.plength=plength
struc.cons_names=cons_names
struc.vars_names=vars_names
struc.vars=transpose(vars)

return, struc
end

; function that reads outputs files with the parallel tempering information and generated
; by the TAMCMC-C++ written in ASCII.
function read_parallel_tempering, file_ptemp, maxentries=maxentries

file_session=3

if n_elements(maxentries) eq 0 then maxentries=3d6 ; 3 millions of inputs maximum by defaut

openr, file_session, file_ptemp

	a='#'
	b=byte(a)
	i=0d
	while EOF(file_session) ne 1 do begin
		while b[0] eq 35 do begin
			readf, file_session, a; // skip comment lines by looking for the # symbol
			b=byte(a);
		endwhile
		while b[0] eq 33 do begin
			pos_eq=where(b eq 61) ; Identify the = symbol... the value should follow the sign
			name_in=strtrim(b[1:pos_eq-1],2); get the variable name
			if name_in eq 'Tcoefs' then Tcoefs=long(str_to_arrdbl(string(b[pos_eq+1:*])))
			if name_in eq 'labels' then vars_names=str_to_arrstr(string(b[pos_eq+1:*]))
			
			readf, file_session, a
			b=byte(a);
		endwhile
		Nvars=n_elements(vars_names)
		vars=get_Ncolumns(file_session, Nvars, maxentries)
	endwhile
close, file_session	

Nchains=n_elements(Tcoefs)
Ndata=n_elements(vars[*,0])

struc={Nchains:0l, Nvars:0l, Ndata:0l, Tcoefs:dblarr(Nchains), $
	   vars_names:strarr(Nvars), vars_ptempering:dblarr(Nvars, Ndata)}
	 
struc.Ndata=Ndata  
struc.Nchains=Nchains
struc.Nvars=Nvars
struc.Tcoefs=Tcoefs
struc.vars_names=vars_names
struc.vars_ptempering=transpose(vars)

return, struc
end

; function that reads outputs files with the logLikelihood, logPrior and logPosterior 
; and generated by the TAMCMC-C++ written in ASCII.
function read_stat_criteria, file_stat_criteria, maxentries=maxentries

file_session=3

if n_elements(maxentries) eq 0 then maxentries=3d6 ; 3 millions of inputs maximum by defaut

openr, file_session, file_stat_criteria

	a='#'
	b=byte(a)
	i=0d
	while EOF(file_session) ne 1 do begin
		while b[0] eq 35 do begin
			readf, file_session, a; // skip comment lines by looking for the # symbol
			b=byte(a);
		endwhile
		while b[0] eq 33 do begin
			pos_eq=where(b eq 61) ; Identify the = symbol... the value should follow the sign
			name_in=strtrim(b[1:pos_eq-1],2); get the variable name
			if name_in eq 'Nchains' then Nchains=long(string(b[pos_eq+1:*]))
			if name_in eq 'labels' then vars_names=str_to_arrstr(string(b[pos_eq+1:*]))
			readf, file_session, a
			b=byte(a);
		endwhile
		Nvars=n_elements(vars_names)
		vars=get_Ncolumns(file_session, Nvars, maxentries)
	endwhile
close, file_session	

Ndata=n_elements(vars[*,0])

vars=transpose(vars)
logLikelihood=vars[0:Nchains-1, *]
logPrior=vars[Nchains:2*Nchains-1, *]
logPosterior=vars[2*Nchains:3*Nchains-1, *]

labels_logLikelihood=vars_names[0:Nchains-1]
labels_logPrior=vars_names[Nchains:2*Nchains-1]
labels_logPosterior=vars_names[2*Nchains:3*Nchains-1]

struc={Nchains:0l, Nvars:0l, Ndata:0l, labels_logLikelihood:strarr(Nchains), $
	   labels_logPrior:strarr(Nchains), labels_logPosterior:strarr(Nchains), $
	   logLikelihood:dblarr(Nchains, Ndata), logPrior:dblarr(Nchains, Ndata), $
	   logPosterior:dblarr(Nchains, Ndata)}
;struc={Nchains:0l, Nvars:0l, Ndata:0l, $
;	   vars_names:strarr(Nvars), stat:dblarr(Nvars, Ndata)}

	 
struc.Ndata=Ndata  
struc.Nchains=Nchains
struc.Nvars=Nvars

struc.labels_logLikelihood=labels_logLikelihood
struc.labels_logPrior=labels_logPrior
struc.labels_logPosterior=labels_logPosterior
;struc.vars_names=vars_names

struc.logLikelihood=logLikelihood
struc.logPrior=logPrior
struc.logPosterior=logPosterior
;struc.stat=transpose(vars)

return, struc
end

; function that reads outputs files of the proposal law parameters mu and generated by 
; the TAMCMC-C++ written in ASCII.
function read_proposal_mus, file_prop_mus, maxentries=maxentries

file_session=3

if n_elements(maxentries) eq 0 then maxentries=3d6 ; 3 millions of inputs maximum by defaut

openr, file_session, file_prop_mus

	a='#'
	b=byte(a)
	i=0d
	while EOF(file_session) ne 1 do begin
		while b[0] eq 35 do begin
			readf, file_session, a; // skip comment lines by looking for the # symbol
			b=byte(a);
		endwhile
		while b[0] eq 33 do begin
			pos_eq=where(b eq 61) ; Identify the = symbol... the value should follow the sign
			name_in=strtrim(b[1:pos_eq-1],2); get the variable name
			if name_in eq 'Nchains' then Nchains=long(string(b[pos_eq+1:*]))
			if name_in eq 'Nvars' then Nvars=long(string(b[pos_eq+1:*]))
			if name_in eq 'chain' then chain=long(string(b[pos_eq+1:*]))
			if name_in eq 'variable_names' then vars_names=str_to_arrstr(string(b[pos_eq+1:*]))
			
			readf, file_session, a
			b=byte(a);
		endwhile
		vars=get_Ncolumns(file_session, Nvars, maxentries)
	endwhile
close, file_session	

Ndata=n_elements(vars[*,0])

struc={Nchains:0l, Nvars:0l, chain:0l, Ndata:0l, vars_names:strarr(Nvars), $
	   mu:dblarr(Nvars, Ndata)}

struc.Ndata=Ndata
struc.Nchains=Nchains
struc.Nvars=Nvars
struc.chain=chain
struc.vars_names=vars_names
struc.mu=transpose(vars)

return, struc
end


; function that reads outputs files of the proposal law parameter sigma and generated by 
; the TAMCMC-C++ written in ASCII.
function read_proposal_sigmas, file_prop_sigmas, maxentries=maxentries

file_session=3

if n_elements(maxentries) eq 0 then maxentries=3d6 ; 3 millions of inputs maximum by defaut

openr, file_session, file_prop_sigmas

	a='#'
	b=byte(a)
	i=0d
	while EOF(file_session) ne 1 do begin
		while b[0] eq 35 do begin
			readf, file_session, a; // skip comment lines by looking for the # symbol
			b=byte(a);
		endwhile
		while b[0] eq 33 do begin
			pos_eq=where(b eq 61) ; Identify the = symbol... the value should follow the sign
			name_in=strtrim(b[1:pos_eq-1],2); get the variable name
			if name_in eq 'Nchains' then Nchains=long(string(b[pos_eq+1:*]))
			
			readf, file_session, a
			b=byte(a);
		endwhile
		vars=get_Ncolumns(file_session, Nchains, maxentries)
	endwhile
close, file_session	

Ndata=n_elements(vars[*,0])

struc={Nchains:0l,  Ndata:0l, sigma:dblarr(Nchains, Ndata)}

struc.Ndata=Ndata
struc.Nchains=Nchains
struc.sigma=transpose(vars)

return, struc
end


; function that reads outputs files of the proposal law parameter Pmove and moded 
; and generated by the TAMCMC-C++ written in ASCII.
function read_proposal_moves, file_prop_moves, maxentries=maxentries

file_session=3

if n_elements(maxentries) eq 0 then maxentries=3d6 ; 3 millions of inputs maximum by defaut

openr, file_session, file_prop_moves

	a='#'
	b=byte(a)
	i=0d
	while EOF(file_session) ne 1 do begin
		while b[0] eq 35 do begin
			readf, file_session, a; // skip comment lines by looking for the # symbol
			b=byte(a);
		endwhile
		while b[0] eq 33 do begin
			pos_eq=where(b eq 61) ; Identify the = symbol... the value should follow the sign
			name_in=strtrim(b[1:pos_eq-1],2); get the variable name
			if name_in eq 'Nchains' then Nchains=long(string(b[pos_eq+1:*]))
			
			readf, file_session, a
			b=byte(a);
		endwhile
		vars=get_Ncolumns(file_session, 2*Nchains, maxentries)
	endwhile
close, file_session	

Ndata=n_elements(vars[*,0])

vars=transpose(vars)

Pmove=vars[0:Nchains-1, *]
moved=vars[Nchains:*, *]

struc={Nchains:0l,  Ndata:0l, Pmove:dblarr(Nchains, Ndata), moved:lonarr(Nchains, Ndata)}

struc.Ndata=Ndata
struc.Nchains=Nchains
struc.Pmove=Pmove
struc.moved=moved

return, struc
end


; function that reads outputs files of the proposal law parameter covarmat
; and generated by the TAMCMC-C++ written in ASCII.
function read_proposal_covarmat, file_prop_covarmat, maxentries=maxentries

file_session=3

if n_elements(maxentries) eq 0 then maxentries=3d6 ; 3 millions of inputs maximum by defaut

openr, file_session, file_prop_covarmat

	maxNdata=2d6 ; maximum number of samples
	
	a='#'
	b=byte(a)
	new_mat=0
	iter=0.;
	while EOF(file_session) ne 1 do begin
		while b[0] eq 35 do begin
			readf, file_session, a; // skip comment lines by looking for the # symbol
			b=byte(a);
		endwhile
		while b[0] eq 33 do begin
			pos_eq=where(b eq 61) ; Identify the = symbol... the value should follow the sign
			name_in=strtrim(b[1:pos_eq-1],2); get the variable name
			if name_in eq 'Nchains' then Nchains=long(string(b[pos_eq+1:*]))
			if name_in eq 'Nvars' then Nvars=long(string(b[pos_eq+1:*]))
			if name_in eq 'chain' then chain=long(string(b[pos_eq+1:*]))
			if name_in eq 'variable_names' then vars_names=str_to_arrstr(string(b[pos_eq+1:*]))
			
			readf, file_session, a
			b=byte(a);
		endwhile
		if b[0] eq '42' then begin
			if iter eq 0 then covarmats=dblarr(maxNdata, Nvars, Nvars) ; detect when we can declare that array
			;readf, file_session, a ; skip lines which indicate the begining of a new covariance matrix (new iteration)
			new_mat=1; a new matrix has begun
		endif 
		if new_mat eq 1 then begin
			vars=get_Ncolumns_Nrows(file_session, Nvars, Nvars) ; get (Nvars, Nvars) elements
			if (EOF(file_session) ne 1) then readf, file_session, a
			covarmats[iter, *, *]=transpose(vars);
			new_mat=0; we finished to read the matrix
			iter=iter+1.
			;stop
		endif
	endwhile
close, file_session	

Ndata=iter 
covarmats=covarmats[0:Ndata-1, *, *]

struc={Nchains:0l, Nvars:0l, chain:0l, Ndata:0l, vars_names:strarr(Nvars), $
	   covarmats:dblarr(Ndata, Nvars, Nvars)}

struc.Ndata=Ndata
struc.Nchains=Nchains
struc.Nvars=Nvars
struc.chain=chain
struc.vars_names=vars_names
struc.covarmats=covarmats

return, struc
end

; Read an input text file... observational constaints
function read_obsdata, file_obsdata, maxentries=maxentries

file_session=3

if n_elements(maxentries) eq 0 then maxentries=1d6 ; 1 millions of inputs maximum by defaut

openr, file_session, file_obsdata

	units=''
	axises=''
	
	a='#'
	b=byte(a)
	i=0d
	while EOF(file_session) ne 1 do begin
		while b[0] eq 35 do begin
			readf, file_session, a; // skip comment lines by looking for the # symbol
			b=byte(a);
		endwhile
		if b[0] eq 33 then begin
			axis_in=strtrim(b[1:*],2); get the infos on axis names
			axises=str_to_arrstr(axis_in)
			Nvars=n_elements(axises)
			
			readf, file_session, a
			b=byte(a);
		endif
		if b[0] eq 42 then begin
			unit_in=strtrim(b[1:*],2); get the infos on axis names
			units=str_to_arrstr(unit_in)
			Nvars=n_elements(units)
			
			readf, file_session, a
			b=byte(a);
		endif
		if Nvars eq 0 then Nvars=2; if Nvars could not be deduce from units or axises, use the default Nvars=2
		vars=get_Ncolumns(file_session, Nvars, maxentries)
	endwhile
close, file_session	

Ndata=n_elements(vars[*,0])

struc={Ndata:0l, Nvars:0l, vars_names:strarr(Nvars), vars:dblarr(Nvars, Ndata), $
		axis_names:strarr(Nvars), axis_units:strarr(Nvars)}

struc.Ndata=Ndata
struc.Nvars=Nvars
struc.axis_names=axises
struc.axis_units=units
struc.vars=transpose(vars)

return, struc
end